# 2020 ì¹´ì¹´ì˜¤ ì¸í„´ì‹­ - ê²½ì£¼ë¡œ ê±´ì„¤

## ë¬¸ì œ

ğŸ”— [ì½”ë”©í…ŒìŠ¤íŠ¸ ì—°ìŠµ - ê²½ì£¼ë¡œ ê±´ì„¤](https://programmers.co.kr/learn/courses/30/lessons/67259?language=javascript)

![image-0](images/image-0.png)

![image-1](images/image-1.png)

## êµ¬í˜„

```javascript
function solution(board) {
  let answer = Number.MAX_VALUE;

  const directions = {
    top: [0, -1],
    down: [0, 1],
    left: [-1, 0],
    right: [1, 0],
  };

  const start = new Node(0, 0, 'init', 0);

  const q = new Queue();
  q.enqueue(start);
  const n = board.length;

  while (!q.isEmpty()) {
    const current = q.dequeue();
    if (current.x === n - 1 && current.y === n - 1) {
      answer = answer > current.cost ? current.cost : answer;
      continue;
    }

    Object.entries(directions).forEach(([direction, value]) => {
      const next = new Node();
      next.x = current.x + value[0];
      next.y = current.y + value[1];
      next.direction = direction;

      if (isOutBoard(next.x, next.y, n)) {
        return;
      }
      if (isWall(next.x, next.y, board)) {
        return;
      }
      if (isBackward(current.direction, direction)) {
        return;
      }

      if (current.direction === 'init' || current.direction === direction) {
        next.cost = current.cost + 100;
      } else if (current.direction !== direction) {
        next.cost = current.cost + 600;
      }

      if (board[next.y][next.x] === 0) {
        board[next.y][next.x] = next.cost;
        q.enqueue(next);
      } else if (board[next.y][next.x] >= next.cost) {
        board[next.y][next.x] = next.cost;
        q.enqueue(next);
      }
    });
  }

  return answer;
}

function isOutBoard(x, y, range) {
  if (x < 0 || y < 0) {
    return true;
  }
  if (x > range - 1 || y > range - 1) {
    return true;
  }
  return false;
}

function isWall(x, y, board) {
  return board[y][x] === 1;
}

function isBackward(cur, next) {
  if (cur === 'left' && next === 'right') {
    return true;
  }
  if (cur === 'right' && next === 'left') {
    return true;
  }
  if (cur === 'top' && next === 'down') {
    return true;
  }
  if (cur === 'down' && next === 'top') {
    return true;
  }
  return false;
}

class Queue {
  constructor() {
    this._arr = [];
  }
  enqueue(item) {
    this._arr.push(item);
  }
  dequeue() {
    return this._arr.shift();
  }
  isEmpty() {
    return this._arr.length === 0;
  }
}

class Node {
  constructor(x, y, direction, cost) {
    this.x = x;
    this.y = y;
    this.direction = direction;
    this.cost = cost;
  }
}
```

### ì–´ë ¤ì› ë˜ ì 

- ìµœë‹¨ ê²½ë¡œ ë¬¸ì œì—ì„œ BFSë¥¼ ë– ì˜¬ë¦¬ëŠ” ê²ƒì´ ì–´ë ¤ì› ë‹¤.

- BFSë¥¼ ì‹¤ì œ ë¬¸ì œì— ì‚¬ìš©í•˜ë ¤ë‹ˆ ì–´ë ¤ì› ë‹¤.

### ë°°ìš´ ì 

- BFSì˜ ì›ë¦¬

  - Queueë¥¼ ì‚¬ìš©í•´ì„œ í˜„ì¬ ë…¸ë“œì—ì„œ ë°©ë¬¸í•  ìˆ˜ ìˆëŠ” ëª¨ë“  ë…¸ë“œë¥¼ íì— ì¶”ê°€í•œë‹¤. (enqueue)

  - Queueì—ì„œ í•˜ë‚˜ë¥¼ êº¼ë‚´ì„œ (dequeue) ë‹¤ì‹œ ë°˜ë³µí•œë‹¤.

- JavaScript Queue êµ¬í˜„

  - Arrayì˜ push, shiftë¥¼ ì´ìš©í•˜ë©´ Queueë¥¼ ê°„ë‹¨í•˜ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

- Object.entriesë¡œ key, value ìˆœíšŒí•˜ê¸°

- forEachì—ì„œ returnì„ ì‚¬ìš©í•˜ì—¬ for ë¬¸ì˜ continueì²˜ëŸ¼ ì‚¬ìš©í•˜ê¸°

  - forEachì—ì„œ break êµ¬í˜„í•˜ê¸° â†’ some í•¨ìˆ˜, every í•¨ìˆ˜ ì‚¬ìš©
